---
title: "Indexing Temporal Relations for Range-Duration Queries"
subtitle: "Supplemental material"
author:
  - Matteo Ceccarello <mceccarello@unibz.it>
  - Anton Dign√∂s <dignoes@inf.unibz.it>
  - Johann Gamper <gamper@inf.unibz.it>
  - Christina Khnaisser <christina.khnaisser@usherbrooke.ca>
execute:
  echo: false
format:
  html:
    self-contained: true
---

This document complements the experimental results of the paper. 
In particular, in this document we provide interactive plots to explore the behavior of different index structures on mixed query workloads.

```{css}
.plot {
  font-size: 12pt;
}
```

```{r setup, echo=F, message=F, warning=F}
library(tidyverse)
library(kableExtra)
library(units)
data <- read_csv("best.csv") %>%
  filter(
    dataset_name %in% c("UZ", "Flight", "Webkit", "MimicIII"),
    time_constraint %in% c("UZ", "UU", "-"),
    duration_constraint %in% c("U", "-")
  ) %>%
  select(
      dataset_name, time_constraint,
      duration_constraint, algorithm_name, qps
  ) %>%
  group_by(dataset_name, time_constraint, duration_constraint) %>%
  distinct(algorithm_name, qps) %>%
  replace_na(list(qps = 0)) %>%
  mutate(
      rank = dense_rank(desc(qps)),
      rank_str = str_c(" {\\footnotesize(", rank, ")}"),
      qps_num = qps,
      qps = qps %>% scales::number(accuracy=1)
  ) %>%
  select(
      dataset = dataset_name,
      time = time_constraint,
      duration = duration_constraint,
      algorithm_name,
      qps, qps_num
  ) %>%
  mutate(
      algorithm_name = case_when(
          algorithm_name == "BTree"          ~ "BTree",
          algorithm_name == "grid-file"      ~ "GridFile",
          algorithm_name == "period-index-*" ~ "Period-Index*",
          algorithm_name == "interval-tree"  ~ "ITree",
          algorithm_name == "rd-index-td"    ~ "RD-Index-td",
          algorithm_name == "rd-index-dt"    ~ "RD-Index-dt",
          algorithm_name == "RTree"          ~ "RTree",
          TRUE ~ algorithm_name
      ),
      algorithm_name = factor(algorithm_name,
          levels = c(
              "RD-Index-td",
              "RD-Index-dt",
              "GridFile",
              "Period-Index*",
              "RTree",
              "ITree",
              "BTree"
          ),
          ordered = TRUE
      )
  ) %>%
  mutate(
      query_type = case_when(
          time == "UZ" && duration == "U" ~ "qrd",
          time == "UU" && duration == "U" ~ "qrd",
          time == "-" && duration == "U"  ~ "qdo",
          time == "UZ" && duration == "-" ~ "qro",
          time == "UU" && duration == "-" ~ "qro",
          T ~ "unknown"
      ),
      query_type = factor(query_type, levels = c("qro", "qdo", "qrd"), ordered = T)
  ) %>%
  ungroup() %>%
  select(
      dataset,
      query = query_type,
      algorithm_name,
      qps, qps_num
  ) %>%
  arrange(algorithm_name)

# ojs_define(data = select(data, dataset, query, algorithm_name, qps_num) %>%
#   pivot_wider(names_from=query, values_from=qps_num))
# ojs_define(tradeoffs = read_csv("tradeoffs.csv"))
```

## Mixed-workload queries

The paper reports on the performance of various index structures for uniform workload queries, i.e. range-only queries, duration-only queries, or range-duration queries.

```{r}
#| tbl-cap: "Table 1, as reported in the paper"
#| tbl-cap-location: top
#| column: screen-inset

data %>% 
  select(dataset, query, algorithm_name, qps) %>%
  pivot_wider(
      names_from = "algorithm_name",
      values_from = "qps"
  ) %>%
  mutate(
      dataset = case_when(
          dataset == "UZ" ~ "Random",
          TRUE ~ dataset
      ),
      dataset = factor(dataset,
          levels = c("Random", "Flight", "Webkit", "MimicIII"),
          ordered = TRUE
      )
  ) %>%
  arrange(dataset, query) %>%
  kbl(align="r") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = T, font_size = 14)

```

A natural question is: how does the performance change when these three types of queries are mixed together?
Using data from the above table we can estimate performance figures for mixed workloads.
In particular, the inverse of the throughputs reported in the above table are the average running time of each specific type of query.
Taking the inverse of the weighted average (where weights are the fraction of queries of each type) is the throughput of the mixed workload:
$$
QPS_{mixed} =
\frac{1}{
  f_{ro} / QPS_{ro} +
  f_{do} / QPS_{do} +
  f_{rd} / QPS_{rd}
}
$$
where $f_{ro}$ is the fraction of range only queries in the workload,
$f_{do}$ is the fraction of duration only queries in the workload,
and $f_{rd}$ is the fraction of range-duration queries.

```{ojs}
import { aq, op } from '@uwdata/arquero'
import { ternaryPlot, barycentric } from "@julesblm/d3-ternary"
d3 = require("d3@7")
```

Using the following radio buttons, we can select on which dataset to focus on.
```{ojs}
viewof datasetName = Inputs.radio(["Random", "Flight", "Webkit", "MimicIII"])
```

```{ojs}
// Function to transform a triplet of number adding up to 1 into a triplet of integers adding up to 100
function roundTriplet(triplet) {
  const [x, y, z] = d3.map(triplet, x => Math.round(x * 100))
  const excess = x + y + z - 100;
  return [x, y, z - excess];
}
```

```{ojs}
// This is the table of all the performance and its tradeoffs
// table = aq.table(tradeoffs)
table = aq.loadCSV("tradeoffs.csv")
```

```{ojs}
// This is the map holding the best index for each workload
bestMapData = table.params({dataName: datasetName}).filter((d, $) => d.dataset == $.dataName)
  .derive({
    triplet: aq.escape(d => roundTriplet([d.frac_ro, d.frac_do, d.frac_rd]))
  })
  .groupby("dataset", "triplet")
  .orderby(d => -d.qps)
  .slice(0, 1)
```

```{ojs}
algoDomain = [
  "RD-index-td"   ,
  "RD-index-dt"   ,
  "Grid-File"     ,
  "Period-Index*" ,
  "R-Tree"        ,
  "Interval-Tree" ,
  "B-Tree"        
];
```

```{ojs}
// This is the subset of data that corresponds to the position under the mouse
triplet = (bestMap != 0)? roundTriplet(bestMap.coords) : [0,0,0]; // Return the impossible triplet if a selection has yet to be made
selectedSubset = d3.filter(table, 
  d => d.dataset == datasetName &&
    Math.round(d.frac_ro * 100) == triplet[0] && 
    Math.round(d.frac_do * 100) == triplet[1] && 
    Math.round(d.frac_rd * 100) == triplet[2])
```

```{ojs}
axisLabels = (g, labels) =>
  g
    .selectAll("text")
    .data(labels, d => d.label)
    .join(
      enter =>
        enter
          .append("text")
          .attr("dy", (d, i) => (i === 0 ? "2em" : ".5em"))
          .attr(
            "transform",
            (label, i) => `translate(${label.position})`
          )
          .attr("text-anchor", "middle")
          .text(label => label.label),
      update =>
        update.attr(
          "transform",
          (label, i) => `translate(${label.position})`
        )
    )
```

```{ojs}
valuesTable = (labels, plot) => html`
<table style="height:50px">
  <thead>
    <tr style="width:33%">${labels.map((label) => `<th>${label}</th>`)}</tr>
  </thead>
  <tbody>
    <tr>${
      plot === 0
        ? `<td colspan="3">
            Hover your mouse over the triangle to select a workload
          </td>`
        : plot.coords.map(c => `<td>${d3.format(".0%")(c)}</td>`)
    } </tr>
  </tbody>
</table>
`
valuesTable(['Range only', 'Duration only', 'Range-duration'], bestMap)
```

::: {layout-ncol=2 .column-page}
```{ojs}
viewof bestMap = {
  const height = 400;
  const width = 500;
  const radius = Math.min(width, height) / 2;
  // to keep the triangle centered
  const yOffset = radius/4;
  // Set up the chart space
  const node = DOM.svg(width, height);
  const svg = d3.select(node);
  const chart = svg
    .append("g")
    .attr("transform", `translate(${width / 2} ${height / 2 + yOffset})`)
    .on("mousemove", handleMouseMove);

  const circle = chart.append("g");
  
  // Handler of mouse hover events. It stores the state
  // underlying the mouse in the SVG node itself.
  function handleMouseMove(d) {
    const xy = d3.pointer(d);
    const inverse = ternary.invert(xy);

    node.dispatchEvent(new CustomEvent("input"), { bubbles: true });
    node.value = {
      coords: inverse,
      data: d.target.__data__
    };
  }

  // Define transformer in ternary coordinates
  const normalBarycentric = barycentric()
    .a(d => d.frac_ro)
    .b(d => d.frac_do)
    .c(d => d.frac_rd);
  const ternary = ternaryPlot(normalBarycentric)
    .radius(radius)
    .labels(["Range only", "Duration only", "Range-Duration"]);

  const axisLabelsGroups = chart
    .append("g")
    .attr("class", "axis-labels")
    .append("g")
    .attr("class", "labels")
    .attr("font-size", 16);

  axisLabelsGroups.call(axisLabels, ternary.axisLabels());
  
  // Add the ternary components to the data
  const ternaryData = d3.map(bestMapData, (d) => {
    const [x, y] = ternary(d);
    return { x, y, ...d };
  });

  // border triangle
  const trianglePath = chart
    .append("path")
    .attr("d", ternary.triangle())
    .attr("fill", "transparent")
    .attr("stroke", "black")
    .attr("stroke-width", 6);

  // Set up color scale
  const color = d3.scaleOrdinal(d3.schemeTableau10)
    .domain(algoDomain);

  // Add the points
  chart.append("g")
    .selectAll("circle")
    .data(ternaryData)
    .join("circle")
    .attr("r", 2)
    .attr("cx", (d) => d.x)
    .attr("cy", (d) => d.y)
    .attr("fill", d => color(d.algorithm))
    .attr("stroke", "none");

  node.value = 0;

  return svg.node();
}
```

```{ojs}
Plot.plot({
  width: 800,
  height: 600,
  x: {
    domain: d3.sort(selectedSubset, d => -d.qps).map(d => d.algorithm)
  },
  color: {
    type: "categorical",
    scheme: "tableau10",
    domain: algoDomain
  },
  marginLeft: 90,
  marginTop: 90,
  marginBottom: 50,
  marks: [
    Plot.barY(
      selectedSubset,
      {
        x: "algorithm",
        y: "qps",
        fill: "algorithm"
      }
    ),
    Plot.text(
      selectedSubset,
      {
        x: "algorithm",
        y: "qps",
        text: d => d3.format("d")(d.qps),
        dy: -10
      }
    ),
    Plot.ruleY([0])
  ]
});
```
:::